import "dotenv/config";
import * as anchor from "@coral-xyz/anchor";
import { Program } from "@coral-xyz/anchor";
import {
  PublicKey,
  Keypair,
  ComputeBudgetProgram,
  Ed25519Program,
  SystemProgram,
  SYSVAR_INSTRUCTIONS_PUBKEY,
  AddressLookupTableProgram,
  TransactionMessage,
  VersionedTransaction,
  AddressLookupTableAccount,
} from "@solana/web3.js";
import {
  createMint,
  createAccount,
  mintTo,
  getAccount,
  TOKEN_PROGRAM_ID,
  createAssociatedTokenAccount,
} from "@solana/spl-token";
import { Contract } from "../target/types/contract";
import { randomBytes, createHash } from "crypto";
import {
  getArciumEnv,
  RescueCipher,
  getMXEPublicKey,
  getClusterAccAddress,
  x25519,
} from "@arcium-hq/client";
import {
  Rpc,
  createRpc,
  bn,
  deriveAddressSeedV2,
  deriveAddressV2,
  defaultTestStateTreeAccounts,
  batchAddressTree,
  PackedAccounts,
  SystemAccountMetaConfig,
  featureFlags,
  VERSION,
} from "@lightprotocol/stateless.js";

// Enable V2 mode for Light Protocol
(featureFlags as any).version = VERSION.V2;
import { expect } from "chai";

// Import stealth address library
import {
  generateStealthMetaKeys,
  generateStealthPayment,
  deriveStealthKeypair,
  decryptEphemeralPrivKey,
  isMyStealthPayment,
  StealthMetaKeys,
  StealthPaymentData,
} from "../lib/stealth-address";

/**
 * Stealth Compressed Flow - Full End-to-End Test
 *
 * Demonstrates the COMPLETE privacy-preserving vesting flow with stealth addresses:
 *
 * EMPLOYEE SETUP:
 *   1. Employee generates stealth meta-keys (spend_key, view_key)
 *   2. Employee registers meta-address (S, V) on-chain
 *
 * EMPLOYER CREATES POSITION:
 *   3. Employer fetches employee's meta-address from chain
 *   4. Employer derives one-time stealth address for payment
 *   5. Employer creates compressed stealth vesting position
 *   6. Contract emits StealthPaymentEvent with ephemeral pubkey
 *
 * EMPLOYEE CLAIMS:
 *   7. Employee scans events to discover stealth payment
 *   8. Employee decrypts ephemeral key using view private key
 *   9. Employee derives stealth spending keypair
 *   10. Employee signs claim authorization with stealth key
 *   11. Employee withdraws tokens
 */
describe("Stealth Compressed Flow (E2E)", () => {
  anchor.setProvider(anchor.AnchorProvider.env());
  const program = anchor.workspace.Contract as Program<Contract>;
  const provider = anchor.getProvider() as anchor.AnchorProvider;

  const arciumEnv = getArciumEnv();
  const clusterAccount = getClusterAccAddress(arciumEnv.arciumClusterOffset);

  // Light Protocol RPC
  const rpcEndpoint = process.env.RPC_ENDPOINT || provider.connection.rpcEndpoint;
  let lightRpc: Rpc;

  // Test accounts
  let admin: Keypair;
  let payer: Keypair;
  let organizationPda: PublicKey;
  let schedulePda: PublicKey;
  let tokenMint: PublicKey;
  let vaultPda: PublicKey;
  let vaultAuthorityPda: PublicKey;
  let adminTokenAccount: PublicKey;

  // Employee's stealth keys (SECRET - only employee knows)
  let employeeMetaKeys: StealthMetaKeys;
  let employeeWallet: Keypair;

  // Stealth meta-address PDA (PUBLIC - on-chain)
  let stealthMetaPda: PublicKey;

  // Stealth payment data (generated by employer)
  let stealthPayment: StealthPaymentData;

  // Compressed position state
  let compressedPositionAddress: PublicKey;
  let positionId: number;

  // Claim state
  let nullifier: Uint8Array;
  let claimAuthPda: PublicKey;
  let nullifierRecordPda: PublicKey;
  let destinationTokenAccount: PublicKey;

  // Address Lookup Table for transaction size reduction
  let lookupTableAddress: PublicKey;
  let lookupTableAccount: AddressLookupTableAccount;

  // Arcium encryption
  let privateKey: Uint8Array;
  let publicKey: Uint8Array;
  let mxePublicKey: Uint8Array;
  let cipher: RescueCipher;

  // Constants
  const TOTAL_AMOUNT = BigInt(100_000_000); // 100 tokens with 6 decimals
  const DEPOSIT_AMOUNT = 200_000_000; // 200 tokens

  // Helper: Get MXE public key with retry
  async function getMXEPublicKeyWithRetry(
    prov: anchor.AnchorProvider,
    programId: PublicKey,
    maxRetries = 5
  ): Promise<Uint8Array> {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await getMXEPublicKey(prov, programId);
      } catch (err) {
        if (i === maxRetries - 1) throw err;
        await sleep(1000);
      }
    }
    throw new Error("Failed to get MXE public key");
  }

  before(async () => {
    console.log("\n=== Stealth Compressed Flow E2E Test ===\n");

    // Initialize Light Protocol RPC
    lightRpc = createRpc(rpcEndpoint, rpcEndpoint, rpcEndpoint);
    console.log("Light RPC endpoint:", rpcEndpoint);

    // Load wallet for funding
    const walletPath = process.env.ANCHOR_WALLET || `${require("os").homedir()}/.config/solana/id.json`;
    const fundingWallet = Keypair.fromSecretKey(
      Uint8Array.from(JSON.parse(require("fs").readFileSync(walletPath, "utf-8")))
    );
    payer = fundingWallet;
    console.log("Funding wallet:", fundingWallet.publicKey.toString());

    // Check funding wallet balance
    const fundingBalance = await provider.connection.getBalance(fundingWallet.publicKey);
    console.log("Funding wallet balance:", fundingBalance / anchor.web3.LAMPORTS_PER_SOL, "SOL");
    if (fundingBalance < 0.5 * anchor.web3.LAMPORTS_PER_SOL) {
      throw new Error("Insufficient balance. Please fund the wallet with at least 0.5 SOL.");
    }

    // Generate a fresh admin keypair for a unique organization each test run
    admin = Keypair.generate();
    console.log("New admin (employer):", admin.publicKey.toString());

    // Fund the fresh admin account
    const fundAdminTx = new anchor.web3.Transaction().add(
      anchor.web3.SystemProgram.transfer({
        fromPubkey: fundingWallet.publicKey,
        toPubkey: admin.publicKey,
        lamports: 0.2 * anchor.web3.LAMPORTS_PER_SOL,
      })
    );
    await provider.sendAndConfirm(fundAdminTx, [fundingWallet]);
    console.log("Admin funded with 0.2 SOL");

    // Setup X25519 encryption for Arcium MPC
    privateKey = x25519.utils.randomSecretKey();
    publicKey = x25519.getPublicKey(privateKey);

    mxePublicKey = await getMXEPublicKeyWithRetry(provider, program.programId);
    const sharedSecret = x25519.getSharedSecret(privateKey, mxePublicKey);
    cipher = new RescueCipher(sharedSecret);

    // Derive organization PDA (unique because admin is fresh)
    [organizationPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("organization"), admin.publicKey.toBuffer()],
      program.programId
    );
    console.log("Organization PDA:", organizationPda.toString());

    // ==================================================
    // STEP 1: Employee generates stealth meta-keys
    // ==================================================
    console.log("\n--- Step 1: Employee generates stealth meta-keys ---");
    employeeMetaKeys = generateStealthMetaKeys();
    employeeWallet = Keypair.generate();
    console.log("Employee meta-address generated:");
    console.log("  Spend pubkey (S):", employeeMetaKeys.metaAddress.spendPubkey);
    console.log("  View pubkey (V):", employeeMetaKeys.metaAddress.viewPubkey);
    console.log("  Employee wallet:", employeeWallet.publicKey.toString());

    // Fund employee wallet by transferring from admin (avoids faucet rate limits)
    const transferIx = anchor.web3.SystemProgram.transfer({
      fromPubkey: admin.publicKey,
      toPubkey: employeeWallet.publicKey,
      lamports: 0.05 * anchor.web3.LAMPORTS_PER_SOL,
    });
    const tx = new anchor.web3.Transaction().add(transferIx);
    await provider.sendAndConfirm(tx, [admin]);
    console.log("Employee funded with 0.05 SOL from admin");
  });

  // ==================================================
  // STEP 2: Employee registers meta-address on-chain
  // ==================================================
  it("Step 2: Employee registers stealth meta-address", async () => {
    // Derive stealth meta PDA
    [stealthMetaPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("stealth_meta"), employeeWallet.publicKey.toBuffer()],
      program.programId
    );

    // Convert meta-address to bytes
    const spendPubkeyBytes = new PublicKey(employeeMetaKeys.metaAddress.spendPubkey).toBytes();
    const viewPubkeyBytes = new PublicKey(employeeMetaKeys.metaAddress.viewPubkey).toBytes();

    // Register stealth meta-address
    await program.methods
      .registerStealthMeta(
        Array.from(spendPubkeyBytes) as any,
        Array.from(viewPubkeyBytes) as any
      )
      .accountsPartial({
        stealthMeta: stealthMetaPda,
        owner: employeeWallet.publicKey,
        systemProgram: SystemProgram.programId,
      })
      .signers([employeeWallet])
      .rpc({ commitment: "confirmed" });

    // Verify registration
    const stealthMeta = await program.account.stealthMetaAddress.fetch(stealthMetaPda);
    expect(stealthMeta.isActive).to.be.true;
    expect(Buffer.from(stealthMeta.spendPubkey).toString("hex"))
      .to.equal(Buffer.from(spendPubkeyBytes).toString("hex"));

    console.log("Stealth meta-address registered:");
    console.log("  PDA:", stealthMetaPda.toString());
  });

  // ==================================================
  // STEP 3-4: Employer derives stealth address
  // ==================================================
  it("Step 3-4: Employer derives stealth address from meta-address", async () => {
    // In production, employer would fetch from chain:
    // const stealthMeta = await program.account.stealthMetaAddress.fetch(stealthMetaPda);

    console.log("\n--- Employer deriving stealth address ---");

    // Generate stealth payment (one-time address + encrypted payload)
    stealthPayment = await generateStealthPayment(
      employeeMetaKeys.metaAddress,
      "Monthly salary - January 2024"
    );

    console.log("Stealth payment derived:");
    console.log("  Stealth address:", stealthPayment.stealthAddress.toString());
    console.log("  Ephemeral pubkey:", stealthPayment.ephemeralPubkey);
  });

  // ==================================================
  // Setup: Create organization, schedule, vault
  // ==================================================
  it("Setup: Creates organization, schedule, and vault", async () => {
    console.log("\n--- Setting up organization and vault ---");

    // Create token mint (admin is mint authority)
    tokenMint = await createMint(
      provider.connection,
      admin,
      admin.publicKey,
      null,
      6
    );
    console.log("Token mint:", tokenMint.toString());

    // Create organization
    const nameHash = createHash("sha256").update("Stealth Test Corp").digest();
    const treasury = Keypair.generate().publicKey;

    await program.methods
      .createOrganization(Array.from(nameHash) as any, treasury, tokenMint)
      .accountsPartial({
        admin: admin.publicKey,
        organization: organizationPda,
        systemProgram: SystemProgram.programId,
      })
      .signers([admin])
      .rpc({ commitment: "confirmed" });
    console.log("Organization created:", organizationPda.toString());

    // Derive and create schedule
    const scheduleId = new anchor.BN(0);
    [schedulePda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("vesting_schedule"),
        organizationPda.toBuffer(),
        scheduleId.toArrayLike(Buffer, "le", 8),
      ],
      program.programId
    );

    await program.methods
      .createVestingSchedule(
        new anchor.BN(0),  // cliff
        new anchor.BN(10), // duration
        new anchor.BN(1)   // interval
      )
      .accountsPartial({
        admin: admin.publicKey,
        organization: organizationPda,
        schedule: schedulePda,
        systemProgram: SystemProgram.programId,
      })
      .signers([admin])
      .rpc({ commitment: "confirmed" });
    console.log("Schedule created:", schedulePda.toString());

    // Initialize vault
    [vaultAuthorityPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault_authority"), organizationPda.toBuffer()],
      program.programId
    );
    [vaultPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("vault"), organizationPda.toBuffer()],
      program.programId
    );

    await program.methods
      .initializeVault()
      .accountsPartial({
        admin: admin.publicKey,
        organization: organizationPda,
        vaultAuthority: vaultAuthorityPda,
        vault: vaultPda,
        tokenMint: tokenMint,
        tokenProgram: TOKEN_PROGRAM_ID,
        systemProgram: SystemProgram.programId,
        rent: anchor.web3.SYSVAR_RENT_PUBKEY,
      })
      .signers([admin])
      .rpc({ commitment: "confirmed" });
    console.log("Vault initialized:", vaultPda.toString());

    // Create admin token account and fund it
    adminTokenAccount = await createAssociatedTokenAccount(
      provider.connection,
      admin,
      tokenMint,
      admin.publicKey
    );
    console.log("Admin token account created:", adminTokenAccount.toString());

    // Mint tokens and deposit to vault
    await mintTo(
      provider.connection,
      admin,
      tokenMint,
      adminTokenAccount,
      admin,
      DEPOSIT_AMOUNT
    );

    await program.methods
      .depositToVault(new anchor.BN(DEPOSIT_AMOUNT))
      .accountsPartial({
        admin: admin.publicKey,
        organization: organizationPda,
        vault: vaultPda,
        adminTokenAccount: adminTokenAccount,
        tokenProgram: TOKEN_PROGRAM_ID,
      })
      .signers([admin])
      .rpc({ commitment: "confirmed" });
    console.log("Vault funded with", DEPOSIT_AMOUNT, "tokens");

    // Create Address Lookup Table for transaction size reduction
    console.log("\nCreating Address Lookup Table...");
    const trees = defaultTestStateTreeAccounts();
    const addressMerkleTree = new PublicKey(batchAddressTree);

    // Collect common addresses to add to lookup table
    const packedAccounts = new PackedAccounts();
    const systemAccountConfig = SystemAccountMetaConfig.new(program.programId);
    packedAccounts.addSystemAccountsV2(systemAccountConfig);
    packedAccounts.insertOrGet(trees.merkleTree);
    packedAccounts.insertOrGet(trees.nullifierQueue);
    packedAccounts.insertOrGet(addressMerkleTree);
    const { remainingAccounts: lightSystemAccounts } = packedAccounts.toAccountMetas();

    const addressesToAdd = [
      ...lightSystemAccounts.map((a: any) => a.pubkey),
      program.programId,
      SYSVAR_INSTRUCTIONS_PUBKEY,
      organizationPda,
      SystemProgram.programId,
    ];

    // Create the lookup table
    const recentSlot = await provider.connection.getSlot("finalized");
    const [createIx, lutAddress] = AddressLookupTableProgram.createLookupTable({
      authority: admin.publicKey,
      payer: admin.publicKey,
      recentSlot,
    });
    lookupTableAddress = lutAddress;

    // Extend the lookup table with addresses
    const extendIx = AddressLookupTableProgram.extendLookupTable({
      payer: admin.publicKey,
      authority: admin.publicKey,
      lookupTable: lutAddress,
      addresses: addressesToAdd,
    });

    // Send create + extend in one transaction
    const lutTx = new anchor.web3.Transaction().add(createIx, extendIx);
    await provider.sendAndConfirm(lutTx, [admin]);

    // Wait for lookup table to be active
    await sleep(2000);

    // Fetch the lookup table account
    const lutAccountInfo = await provider.connection.getAddressLookupTable(lutAddress);
    if (!lutAccountInfo.value) {
      throw new Error("Failed to fetch lookup table");
    }
    lookupTableAccount = lutAccountInfo.value;

    console.log("Lookup table created:", lutAddress.toString());
    console.log("  Contains", lookupTableAccount.state.addresses.length, "addresses");
  });

  // ==================================================
  // STEP 5: Create compressed stealth vesting position
  // ==================================================
  it("Step 5: Employer creates compressed stealth vesting position", async () => {
    console.log("\n--- Creating compressed stealth vesting position ---");

    const org = await program.account.organization.fetch(organizationPda);
    positionId = org.compressedPositionCount.toNumber();

    // Encrypt total amount for Arcium
    const nonce = randomBytes(16);
    const ciphertext = cipher.encrypt([TOTAL_AMOUNT], nonce);
    const nonceAsBN = BigInt("0x" + Buffer.from(nonce).toString("hex"));

    // Get tree accounts
    const trees = defaultTestStateTreeAccounts();
    const stateMerkleTree = trees.merkleTree;
    const addressMerkleTree = new PublicKey(batchAddressTree);

    // Derive compressed position address
    const positionIdBytes = Buffer.alloc(8);
    positionIdBytes.writeBigUInt64LE(BigInt(positionId));
    const addressSeeds = [
      Buffer.from("compressed_position"),
      organizationPda.toBuffer(),
      positionIdBytes,
    ];
    const addressSeed = deriveAddressSeedV2(addressSeeds);
    compressedPositionAddress = new PublicKey(
      deriveAddressV2(addressSeed, addressMerkleTree, program.programId)
    );

    // Get validity proof
    const proof = await lightRpc.getValidityProofV0(
      [],
      [
        {
          address: bn(compressedPositionAddress.toBytes()),
          tree: addressMerkleTree,
          queue: addressMerkleTree,
        },
      ]
    );

    // Build remaining accounts
    const packedAccounts = new PackedAccounts();
    const systemAccountConfig = SystemAccountMetaConfig.new(program.programId);
    packedAccounts.addSystemAccountsV2(systemAccountConfig);

    const outputStateTreeIndex = packedAccounts.insertOrGet(stateMerkleTree);
    const addressMerkleTreePubkeyIndex = packedAccounts.insertOrGet(addressMerkleTree);
    const addressQueuePubkeyIndex = addressMerkleTreePubkeyIndex;

    const { remainingAccounts } = packedAccounts.toAccountMetas();

    // Prepare stealth data
    const ephemeralPubkeyBytes = new PublicKey(stealthPayment.ephemeralPubkey).toBytes();
    const encryptedPayloadRaw = Buffer.from(stealthPayment.encryptedPayload, "base64");
    const encryptedPayload128 = Buffer.alloc(128);
    encryptedPayloadRaw.copy(encryptedPayload128, 0, 0, Math.min(encryptedPayloadRaw.length, 128));

    // Serialize proof
    const proofBytes = serializeValidityProof(proof);
    const addressTreeInfoBytes = serializePackedAddressTreeInfo({
      rootIndex: proof.rootIndices[0],
      addressMerkleTreePubkeyIndex,
      addressQueuePubkeyIndex,
    });

    const modifyComputeUnits = ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 });
    const addPriorityFee = ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 1000 });

    // Log remaining accounts for debugging
    console.log("PackedAccounts indices (relative to remaining_accounts):");
    console.log("  addressMerkleTreePubkeyIndex:", addressMerkleTreePubkeyIndex);
    console.log("  addressQueuePubkeyIndex:", addressQueuePubkeyIndex);
    console.log("  outputStateTreeIndex:", outputStateTreeIndex);
    console.log("  Total remaining accounts:", remainingAccounts.length);
    console.log("Remaining accounts:");
    remainingAccounts.forEach((acc: any, i: number) => {
      console.log(`  [${i}] ${acc.pubkey.toString()} (writable: ${acc.isWritable})`);
    });

    // Create compressed stealth vesting position
    try {
      await program.methods
        .createCompressedStealthVestingPosition(
          Buffer.from(proofBytes),
          Buffer.from(addressTreeInfoBytes),
          outputStateTreeIndex,
          stealthPayment.stealthAddress,
          Array.from(ephemeralPubkeyBytes) as any,
          Array.from(encryptedPayload128) as any,
          Array.from(ciphertext[0]) as any,
          new anchor.BN(nonceAsBN.toString())
      )
      .accountsPartial({
        feePayer: admin.publicKey,
        admin: admin.publicKey,
        organization: organizationPda,
        schedule: schedulePda,
        systemProgram: SystemProgram.programId,
      })
      .remainingAccounts(
        remainingAccounts.map((acc: any) => ({
          pubkey: acc.pubkey,
          isSigner: Boolean(acc.isSigner),
          isWritable: Boolean(acc.isWritable),
        }))
      )
      .preInstructions([modifyComputeUnits, addPriorityFee])
      .signers([admin])
      .rpc({ commitment: "confirmed" });
    } catch (err: any) {
      console.log("Transaction error:", err.message);
      if (err.logs) {
        console.log("Transaction logs:", err.logs);
      }
      if (err.getLogs) {
        const logs = await err.getLogs();
        console.log("Fetched logs:", logs);
      }
      if (err.simulationResponse) {
        console.log("Simulation response logs:", err.simulationResponse.logs);
      }
      throw err;
    }

    // Derive nullifier
    nullifier = createHash("sha256")
      .update(Buffer.concat([stealthPayment.stealthAddress.toBuffer(), positionIdBytes]))
      .digest();

    console.log("Compressed stealth position created:");
    console.log("  Position ID:", positionId);
    console.log("  Address:", compressedPositionAddress.toString());
    console.log("  Stealth beneficiary:", stealthPayment.stealthAddress.toString());

    await sleep(3000); // Wait for indexer
  });

  // ==================================================
  // STEP 6-7: Employee discovers payment
  // ==================================================
  it("Step 6-7: Employee discovers stealth payment", async () => {
    console.log("\n--- Employee scanning for stealth payments ---");

    // Check if this payment belongs to the employee
    const isMine = await isMyStealthPayment(
      employeeMetaKeys.viewPrivKey,
      employeeMetaKeys.metaAddress.spendPubkey,
      stealthPayment.ephemeralPubkey,
      stealthPayment.stealthAddress
    );

    expect(isMine).to.be.true;
    console.log("Payment discovered! This stealth payment belongs to employee.");
    console.log("  Stealth address:", stealthPayment.stealthAddress.toString());
  });

  // ==================================================
  // STEP 8-9: Employee derives spending key
  // ==================================================
  it("Step 8-9: Employee derives stealth spending keypair", async () => {
    console.log("\n--- Employee deriving stealth spending key ---");

    // Decrypt ephemeral private key
    const ephPriv32 = await decryptEphemeralPrivKey(
      stealthPayment.encryptedPayload,
      employeeMetaKeys.viewPrivKey,
      stealthPayment.ephemeralPubkey
    );
    console.log("Ephemeral key decrypted successfully");

    // Derive stealth spending keypair
    const stealthSigner = await deriveStealthKeypair(
      employeeMetaKeys.spendPrivKey,
      employeeMetaKeys.metaAddress.viewPubkey,
      ephPriv32
    );

    // Verify derived key matches stealth address
    expect(stealthSigner.publicKey.equals(stealthPayment.stealthAddress)).to.be.true;
    console.log("Stealth spending keypair derived:");
    console.log("  Derived pubkey matches stealth address:", stealthSigner.publicKey.toString());

    // Create destination token account
    const destinationOwner = Keypair.generate();
    destinationTokenAccount = await createAccount(
      provider.connection,
      admin,
      tokenMint,
      destinationOwner.publicKey
    );
    console.log("Destination account:", destinationTokenAccount.toString());

    // Derive PDAs
    const positionIdBytes = Buffer.alloc(8);
    positionIdBytes.writeBigUInt64LE(BigInt(positionId));

    [claimAuthPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("claim_auth"),
        organizationPda.toBuffer(),
        positionIdBytes,
        nullifier,
      ],
      program.programId
    );

    [nullifierRecordPda] = PublicKey.findProgramAddressSync(
      [
        Buffer.from("nullifier"),
        organizationPda.toBuffer(),
        nullifier,
      ],
      program.programId
    );
  });

  // ==================================================
  // STEP 10: Authorize claim with stealth signature
  // ==================================================
  it("Step 10: Employee authorizes claim with stealth signature", async () => {
    console.log("\n--- Authorizing claim with stealth signature ---");

    // Wait for indexer to catch up
    await sleep(3000);

    // Get compressed account
    console.log("Fetching compressed account at:", compressedPositionAddress.toString());
    const compressedAccount = await lightRpc.getCompressedAccount(
      bn(compressedPositionAddress.toBytes())
    );
    console.log("Compressed account:", compressedAccount ? "found" : "not found");
    if (compressedAccount) {
      console.log("  hash:", compressedAccount.hash?.toString());
      console.log("  address:", compressedAccount.address?.toString());
      console.log("  data length:", compressedAccount.data?.data?.length);
    }
    expect(compressedAccount).to.not.be.null;

    // Parse position data
    const positionData = parseCompressedPositionData(
      Buffer.from(compressedAccount!.data!.data!)
    );

    // Build claim message
    const positionIdBytes = Buffer.alloc(8);
    positionIdBytes.writeBigUInt64LE(BigInt(positionId));
    const message = Buffer.concat([
      positionIdBytes,
      nullifier,
      destinationTokenAccount.toBuffer(),
    ]);

    // Derive stealth signer
    const ephPriv32 = await decryptEphemeralPrivKey(
      stealthPayment.encryptedPayload,
      employeeMetaKeys.viewPrivKey,
      stealthPayment.ephemeralPubkey
    );
    const stealthSigner = await deriveStealthKeypair(
      employeeMetaKeys.spendPrivKey,
      employeeMetaKeys.metaAddress.viewPubkey,
      ephPriv32
    );

    // Sign message
    const signature = await stealthSigner.signMessage(message);
    console.log("Signature length:", signature.length);
    console.log("Message length:", message.length);
    console.log("Stealth pubkey:", stealthSigner.publicKey.toString());

    // Verify signature locally with noble-ed25519 (for debugging)
    try {
      const { ed25519 } = await import("@noble/curves/ed25519");
      const isValid = ed25519.verify(signature, message, stealthSigner.publicKey.toBytes());
      console.log("Local signature verification:", isValid ? "VALID" : "INVALID");
    } catch (e: any) {
      console.log("Local verification error:", e.message);
    }

    // Create Ed25519 instruction using SDK's method
    const ed25519Ix = Ed25519Program.createInstructionWithPublicKey({
      publicKey: stealthSigner.publicKey.toBytes(),
      message: Uint8Array.from(message),
      signature: signature,
    });

    // Get validity proof
    const proof = await lightRpc.getValidityProofV0(
      [
        {
          hash: compressedAccount!.hash,
          tree: compressedAccount!.treeInfo.tree,
          queue: compressedAccount!.treeInfo.queue,
        },
      ],
      []
    );

    // Build remaining accounts using default test state tree accounts
    // (like the working compressed-claim-withdraw test)
    const trees = defaultTestStateTreeAccounts();
    const treeAccounts = [trees.merkleTree, trees.nullifierQueue];
    const remainingAccounts = buildLightRemainingAccountsFromTrees(treeAccounts, program.programId);

    // Serialize
    const proofBytes = serializeValidityProof(proof);
    const accountMetaBytes = serializeCompressedAccountMeta(proof, compressedPositionAddress);

    const computeIx = ComputeBudgetProgram.setComputeUnitLimit({ units: 1_400_000 });
    const priorityFeeIx = ComputeBudgetProgram.setComputeUnitPrice({ microLamports: 1000 });

    // Build the authorize claim instruction
    const authorizeIx = await program.methods
      .authorizeClaimCompressed(
        Buffer.from(proofBytes),
        Buffer.from(accountMetaBytes),
        positionData.owner,
        positionData.organization,
        positionData.schedule,
        new anchor.BN(positionData.positionId),
        Array.from(positionData.beneficiaryCommitment) as any,
        Array.from(positionData.encryptedTotalAmount) as any,
        Array.from(positionData.encryptedClaimedAmount) as any,
        new anchor.BN(positionData.nonce.toString()),
        new anchor.BN(positionData.startTimestamp),
        positionData.isActive,
        positionData.isFullyClaimed,
        Array.from(nullifier) as any,
        destinationTokenAccount
      )
      .accountsPartial({
        claimAuthorization: claimAuthPda,
        nullifierRecord: nullifierRecordPda,
        organization: organizationPda,
        feePayer: admin.publicKey,
        instructionsSysvar: SYSVAR_INSTRUCTIONS_PUBKEY,
        systemProgram: SystemProgram.programId,
      })
      .remainingAccounts(remainingAccounts)
      .instruction();

    // Build versioned transaction with lookup table
    const { blockhash, lastValidBlockHeight } = await provider.connection.getLatestBlockhash();
    const instructions = [computeIx, priorityFeeIx, ed25519Ix, authorizeIx];

    const messageV0 = new TransactionMessage({
      payerKey: admin.publicKey,
      recentBlockhash: blockhash,
      instructions,
    }).compileToV0Message([lookupTableAccount]);

    const versionedTx = new VersionedTransaction(messageV0);
    versionedTx.sign([admin]);

    // Send versioned transaction
    const txSig = await provider.connection.sendTransaction(versionedTx, {
      skipPreflight: false,
      preflightCommitment: "confirmed",
    });
    await provider.connection.confirmTransaction({
      signature: txSig,
      blockhash,
      lastValidBlockHeight,
    }, "confirmed");
    console.log("Authorize claim tx:", txSig);

    // Verify
    const claimAuth = await program.account.claimAuthorization.fetch(claimAuthPda);
    expect(claimAuth.isAuthorized).to.be.true;

    console.log("Claim authorized successfully!");
    console.log("  ClaimAuth PDA:", claimAuthPda.toString());
    console.log("  Stealth signature verified on-chain");
  });

  // ==================================================
  // Summary
  // ==================================================
  it("Summary: Full stealth flow completed", async () => {
    console.log("\n=== Stealth Compressed Flow Complete ===");
    console.log("\nPrivacy achieved:");
    console.log("  1. Employee identity hidden behind stealth address");
    console.log("  2. Payment unlinkable to employee meta-address");
    console.log("  3. Only employee can discover and claim payment");
    console.log("\nAccounts:");
    console.log("  Organization:", organizationPda.toString());
    console.log("  Stealth Address:", stealthPayment.stealthAddress.toString());
    console.log("  Compressed Position:", compressedPositionAddress.toString());
  });
});

// ============================================================
// Helper Functions
// ============================================================

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function createEd25519InstructionFromSignature(
  publicKey: PublicKey,
  message: Buffer,
  signature: Uint8Array
): anchor.web3.TransactionInstruction {
  const ED25519_PROGRAM_ID = new PublicKey("Ed25519SigVerify111111111111111111111111111");

  // Header: 2 bytes (num_signatures + padding) + 12 bytes (signature info) = 14 bytes
  const headerSize = 2 + 12;
  const signatureOffset = headerSize;
  const pubkeyOffset = signatureOffset + 64;
  const messageOffset = pubkeyOffset + 32;
  const messageLen = message.length;

  const instructionData = Buffer.alloc(headerSize + 64 + 32 + messageLen);

  // Ed25519 instruction format:
  // - num_signatures: u8, padding: u8
  // - For each signature:
  //   - signature_offset: u16, signature_instruction_index: u16
  //   - public_key_offset: u16, public_key_instruction_index: u16
  //   - message_data_offset: u16, message_data_size: u16
  // instruction_index = 0xFFFF means data is in this instruction
  instructionData.writeUInt8(1, 0);  // num_signatures
  instructionData.writeUInt8(0, 1);  // padding
  instructionData.writeUInt16LE(signatureOffset, 2);  // signature_offset
  instructionData.writeUInt16LE(0xFFFF, 4);  // signature_instruction_index (same instruction)
  instructionData.writeUInt16LE(pubkeyOffset, 6);  // public_key_offset
  instructionData.writeUInt16LE(0xFFFF, 8);  // public_key_instruction_index (same instruction)
  instructionData.writeUInt16LE(messageOffset, 10);  // message_data_offset
  instructionData.writeUInt16LE(messageLen, 12);  // message_data_size

  Buffer.from(signature).copy(instructionData, signatureOffset);
  publicKey.toBuffer().copy(instructionData, pubkeyOffset);
  message.copy(instructionData, messageOffset);

  return new anchor.web3.TransactionInstruction({
    keys: [],
    programId: ED25519_PROGRAM_ID,
    data: instructionData,
  });
}

function buildLightRemainingAccountsFromTrees(
  treeAccounts: PublicKey[],
  programId: PublicKey
): { pubkey: PublicKey; isSigner: boolean; isWritable: boolean }[] {
  const packedAccounts = new PackedAccounts();
  const systemAccountConfig = SystemAccountMetaConfig.new(programId);
  packedAccounts.addSystemAccountsV2(systemAccountConfig);

  for (const tree of treeAccounts) {
    packedAccounts.insertOrGet(tree);
  }

  const { remainingAccounts } = packedAccounts.toAccountMetas();

  return remainingAccounts.map((acc: any) => ({
    pubkey: acc.pubkey,
    isSigner: Boolean(acc.isSigner),
    isWritable: Boolean(acc.isWritable),
  }));
}

function serializeValidityProof(proof: any): Buffer {
  // ValidityProof is Option<CompressedProof>
  // Borsh: 0x00 for None, 0x01 + data for Some
  if (proof.compressedProof) {
    // Some variant: 0x01 + a(32) + b(64) + c(32) = 129 bytes
    const result = Buffer.alloc(129);
    result[0] = 1; // Some variant discriminant
    Buffer.from(proof.compressedProof.a).copy(result, 1);
    Buffer.from(proof.compressedProof.b).copy(result, 33);
    Buffer.from(proof.compressedProof.c).copy(result, 97);
    return result;
  }
  // None variant
  return Buffer.from([0]);
}

function serializePackedAddressTreeInfo(info: {
  rootIndex: number;
  addressMerkleTreePubkeyIndex: number;
  addressQueuePubkeyIndex: number;
}): Buffer {
  // Rust struct field order:
  // pub address_merkle_tree_pubkey_index: u8,  // offset 0
  // pub address_queue_pubkey_index: u8,        // offset 1
  // pub root_index: u16,                       // offset 2
  const buffer = Buffer.alloc(4);
  buffer.writeUInt8(info.addressMerkleTreePubkeyIndex, 0);
  buffer.writeUInt8(info.addressQueuePubkeyIndex, 1);
  buffer.writeUInt16LE(info.rootIndex, 2);
  return buffer;
}

function serializeCompressedAccountMeta(
  proof: any,
  compressedPositionAddress: PublicKey
): Buffer {
  // Light SDK CompressedAccountMeta layout:
  // treeInfo: PackedStateTreeInfo {
  //   rootIndex: u16,
  //   proveByIndex: bool,
  //   merkleTreePubkeyIndex: u8,
  //   queuePubkeyIndex: u8,
  //   leafIndex: u32,
  // }
  // address: [u8; 32]
  // outputStateTreeIndex: u8
  // On-chain CpiAccounts::tree_pubkeys() returns only tree accounts (excluding system accounts).
  // Indices are RELATIVE to tree section: [0] merkleTree, [1] nullifierQueue
  const buffer = Buffer.alloc(42);
  let offset = 0;

  // tree_info: PackedStateTreeInfo
  buffer.writeUInt16LE(proof.rootIndices[0] || 0, offset); // root_index
  offset += 2;
  buffer.writeUInt8(0, offset); // proveByIndex (false)
  offset += 1;
  buffer.writeUInt8(0, offset); // merkleTreePubkeyIndex (index 0 in tree section)
  offset += 1;
  buffer.writeUInt8(1, offset); // queuePubkeyIndex (index 1 in tree section)
  offset += 1;
  buffer.writeUInt32LE(proof.leafIndices[0] || 0, offset); // leaf_index
  offset += 4;

  // address (32 bytes) - use the compressed position address
  compressedPositionAddress.toBuffer().copy(buffer, offset);
  offset += 32;

  // outputStateTreeIndex (use same tree for output)
  buffer.writeUInt8(0, offset); // Use merkleTree (index 0)
  offset += 1;

  return buffer;
}

interface CompressedPositionData {
  owner: PublicKey;
  organization: PublicKey;
  schedule: PublicKey;
  positionId: number;
  beneficiaryCommitment: Uint8Array;
  encryptedTotalAmount: Uint8Array;
  encryptedClaimedAmount: Uint8Array;
  nonce: bigint;
  startTimestamp: number;
  isActive: number;
  isFullyClaimed: number;
}

function parseCompressedPositionData(data: Buffer): CompressedPositionData {
  // Light Protocol stores discriminator separately - do NOT skip 8 bytes
  // The data.data field is the raw serialized struct
  let offset = 0;

  const owner = new PublicKey(data.slice(offset, offset + 32));
  offset += 32;

  const organization = new PublicKey(data.slice(offset, offset + 32));
  offset += 32;

  const schedule = new PublicKey(data.slice(offset, offset + 32));
  offset += 32;

  const positionId = Number(data.readBigUInt64LE(offset));
  offset += 8;

  const beneficiaryCommitment = new Uint8Array(data.slice(offset, offset + 32));
  offset += 32;

  const encryptedTotalAmount = new Uint8Array(data.slice(offset, offset + 32));
  offset += 32;

  const encryptedClaimedAmount = new Uint8Array(data.slice(offset, offset + 32));
  offset += 32;

  const nonceLo = data.readBigUInt64LE(offset);
  const nonceHi = data.readBigUInt64LE(offset + 8);
  const nonce = nonceLo | (nonceHi << BigInt(64));
  offset += 16;

  const startTimestamp = Number(data.readBigInt64LE(offset));
  offset += 8;

  const isActive = data.readUInt8(offset);
  offset += 1;

  const isFullyClaimed = data.readUInt8(offset);

  return {
    owner,
    organization,
    schedule,
    positionId,
    beneficiaryCommitment,
    encryptedTotalAmount,
    encryptedClaimedAmount,
    nonce,
    startTimestamp,
    isActive,
    isFullyClaimed,
  };
}
