use anchor_lang::prelude::*;

// ============================================================
// Groth16 Verification for Noir ZK Circuits on Solana
//
// Uses Solana's native alt_bn128 syscalls for bn254 curve operations:
// - alt_bn128_addition: G1 point addition
// - alt_bn128_multiplication: G1 scalar multiplication
// - alt_bn128_pairing: Pairing check on bn254
//
// Noir circuits (via Barretenberg) export Groth16 proofs on bn254.
// Verification: e(A, B) * e(-alpha, beta) * e(-vk_x, gamma) * e(-C, delta) == 1
// ============================================================

/// The alt_bn128 field modulus p for point negation.
/// p = 21888242871839275222246405745257275088696311157297823662689037894645226208583
const ALT_BN128_FIELD_MODULUS: [u8; 32] = [
    0x30, 0x64, 0x4E, 0x72, 0xE1, 0x31, 0xA0, 0x29,
    0xB8, 0x50, 0x45, 0xB6, 0x81, 0x81, 0x58, 0x5D,
    0x97, 0x81, 0x6A, 0x91, 0x68, 0x71, 0xCA, 0x8D,
    0x3C, 0x20, 0x8C, 0x16, 0xD8, 0x7C, 0xFD, 0x47,
];

// Note: Operation type constants are defined in solana_bn254::prelude
// ALT_BN128_ADD = 0, ALT_BN128_SUB = 1, ALT_BN128_MUL = 2, ALT_BN128_PAIRING = 3

/// Groth16 verification key for a specific circuit.
/// Contains the trusted setup parameters required for proof verification.
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct VerificationKey {
    /// Alpha point on G1 - 64 bytes (two 32-byte big-endian field elements x, y)
    pub alpha_g1: [u8; 64],
    /// Beta point on G2 - 128 bytes (four 32-byte field elements)
    pub beta_g2: [u8; 128],
    /// Gamma point on G2 - 128 bytes
    pub gamma_g2: [u8; 128],
    /// Delta point on G2 - 128 bytes
    pub delta_g2: [u8; 128],
    /// IC (Initial Conditions) points on G1 - one per public input + 1.
    /// ic[0] is the base, ic[1..] correspond to each public input.
    /// For withdrawal_proof: 5 points (4 public inputs + 1)
    /// For identity_proof: 2 points (1 public input + 1)
    /// For eligibility_proof: 5 points (4 public inputs + 1)
    pub ic: Vec<[u8; 64]>,
}

/// Groth16 proof consisting of three curve points (A, B, C).
/// Generated by the Noir circuit prover (Barretenberg backend).
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct Groth16Proof {
    /// Proof point A on G1 (64 bytes uncompressed)
    pub a: [u8; 64],
    /// Proof point B on G2 (128 bytes uncompressed)
    pub b: [u8; 128],
    /// Proof point C on G1 (64 bytes uncompressed)
    pub c: [u8; 64],
}

/// Public inputs for the withdrawal proof circuit.
/// Circuit proves: "I know a valid vesting position in state_root, for epoch_id,
/// with unused nullifier, and I'm entitled to withdraw."
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct WithdrawalPublicInputs {
    /// Merkle root of the compressed vesting state tree
    pub state_root: [u8; 32],
    /// Current epoch identifier (time-bucketed for privacy)
    pub epoch_id: u64,
    /// Nullifier to prevent double-claiming (hash of secret + position)
    pub nullifier: [u8; 32],
    /// Commitment to the withdrawal parameters
    pub withdrawal_commitment: [u8; 32],
}

/// Public inputs for the identity proof circuit.
/// Circuit proves: "I know the secret behind this position commitment."
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct IdentityPublicInputs {
    /// Commitment binding the prover to a specific position
    pub position_commitment: [u8; 32],
}

/// Public inputs for the eligibility proof circuit.
/// Circuit proves: "I am the beneficiary of this position and have not claimed yet."
#[derive(AnchorSerialize, AnchorDeserialize, Clone, Debug)]
pub struct EligibilityPublicInputs {
    /// Hash commitment of the beneficiary's identity
    pub beneficiary_commitment: [u8; 32],
    /// Nullifier for this specific claim (prevents double-spend)
    pub nullifier: [u8; 32],
    /// Identifier for the vesting position being claimed
    pub position_id: [u8; 32],
    /// Commitment binding to a specific position state
    pub position_commitment: [u8; 32],
}

/// Verify a Groth16 proof against public inputs.
///
/// Implements the standard Groth16 verification equation:
///   e(A, B) == e(alpha, beta) * e(vk_x, gamma) * e(C, delta)
///
/// Equivalently (as a single pairing product check):
///   e(A, B) * e(-alpha, beta) * e(-vk_x, gamma) * e(-C, delta) == 1
///
/// Where vk_x = IC[0] + sum(IC[i+1] * public_input[i]) for all public inputs.
///
/// # Arguments
/// * `vk` - The verification key from trusted setup
/// * `proof` - The Groth16 proof (A, B, C points)
/// * `public_inputs` - Array of 32-byte scalars (one per public input)
///
/// # Returns
/// * `Ok(true)` if the proof is valid
/// * `Ok(false)` if the proof is invalid
/// * `Err(...)` if a computation fails (malformed points, etc.)
pub fn verify_groth16(
    vk: &VerificationKey,
    proof: &Groth16Proof,
    public_inputs: &[[u8; 32]],
) -> Result<bool> {
    // Validate that we have the right number of IC points
    require!(
        vk.ic.len() == public_inputs.len() + 1,
        crate::errors::ShadowVestError::InvalidPublicInputCount
    );

    // Step 1: Compute the public input linear combination
    // vk_x = IC[0] + IC[1]*input[0] + IC[2]*input[1] + ... + IC[n]*input[n-1]
    let vk_x = compute_public_input_lc(&vk.ic, public_inputs)?;

    // Step 2: Negate points for the pairing check.
    // Standard Groth16 verification equation:
    //   e(A, B) == e(alpha, beta) * e(vk_x, gamma) * e(C, delta)
    //
    // Rearranged as a single pairing product equation (checking == identity):
    //   e(A, B) * e(-alpha, beta) * e(-vk_x, gamma) * e(-C, delta) == 1
    let neg_vk_x = negate_g1(&vk_x);
    let neg_c = negate_g1(&proof.c);

    pairing_check(
        &proof.a,
        &proof.b,
        &negate_g1(&vk.alpha_g1),
        &vk.beta_g2,
        &neg_vk_x,
        &vk.gamma_g2,
        &neg_c,
        &vk.delta_g2,
    )
}

/// Compute the public input linear combination on G1.
///
/// vk_x = IC[0] + sum(IC[i+1] * public_input[i]) for i in 0..n
///
/// Uses alt_bn128_multiplication for scalar mul and alt_bn128_addition for point addition.
///
/// # Arguments
/// * `ic` - The IC points from the verification key (n+1 points for n public inputs)
/// * `public_inputs` - The public input scalars (32 bytes each, big-endian)
///
/// # Returns
/// The resulting G1 point (64 bytes)
fn compute_public_input_lc(
    ic: &[[u8; 64]],
    public_inputs: &[[u8; 32]],
) -> Result<[u8; 64]> {
    // Start with IC[0]
    let mut vk_x = ic[0];

    // For each public input, compute IC[i+1] * input[i] and add to vk_x
    for (i, input) in public_inputs.iter().enumerate() {
        // Scalar multiplication: IC[i+1] * input[i]
        // Input format: 64-byte G1 point || 32-byte scalar (96 bytes total)
        let mut mul_input = [0u8; 96];
        mul_input[..64].copy_from_slice(&ic[i + 1]);
        mul_input[64..96].copy_from_slice(input);

        let mul_result = alt_bn128_multiplication(&mul_input)
            .map_err(|_| crate::errors::ShadowVestError::Bn128GroupOpFailed)?;

        // Point addition: vk_x + (IC[i+1] * input[i])
        // Input format: 64-byte G1 point || 64-byte G1 point (128 bytes total)
        let mut add_input = [0u8; 128];
        add_input[..64].copy_from_slice(&vk_x);
        add_input[64..128].copy_from_slice(&mul_result);

        vk_x = alt_bn128_addition(&add_input)
            .map_err(|_| crate::errors::ShadowVestError::Bn128GroupOpFailed)?;
    }

    Ok(vk_x)
}

/// Negate a G1 point on the alt_bn128 curve.
///
/// For a point (x, y), the negation is (x, p - y) where p is the field modulus.
/// This is equivalent to reflecting the point across the x-axis.
///
/// # Arguments
/// * `point` - A 64-byte uncompressed G1 point (32-byte x || 32-byte y, big-endian)
///
/// # Returns
/// The negated G1 point (64 bytes)
fn negate_g1(point: &[u8; 64]) -> [u8; 64] {
    let mut result = [0u8; 64];
    // Copy x-coordinate unchanged
    result[..32].copy_from_slice(&point[..32]);

    // Check if y is zero (point at infinity) - no negation needed
    let mut y_is_zero = true;
    for &b in &point[32..64] {
        if b != 0 {
            y_is_zero = false;
            break;
        }
    }

    if y_is_zero {
        // Point at infinity or y=0, return as-is
        result[32..64].copy_from_slice(&point[32..64]);
    } else {
        // Compute p - y using big-endian subtraction
        // p is the field modulus ALT_BN128_FIELD_MODULUS
        let mut borrow: u16 = 0;
        // Process from least significant byte (index 31) to most significant (index 0)
        for i in (0..32).rev() {
            let p_byte = ALT_BN128_FIELD_MODULUS[i] as u16;
            let y_byte = point[32 + i] as u16;
            let diff = p_byte.wrapping_sub(y_byte).wrapping_sub(borrow);
            result[32 + i] = diff as u8;
            borrow = if p_byte < y_byte + borrow { 1 } else { 0 };
        }
    }

    result
}

/// Perform the Groth16 pairing check using Solana's alt_bn128_pairing syscall.
///
/// Verifies: e(a, b) * e(neg_alpha, beta) * e(neg_vk_x, gamma) * e(neg_c, delta) == 1
///
/// The pairing input is formatted as N pairs of (G1, G2) points.
/// Each pair is 192 bytes (64 G1 + 128 G2).
/// For 4 pairs: 768 bytes total.
///
/// The syscall returns a 32-byte result where a value of 1 means the pairing
/// product equals the identity (verification succeeds).
///
/// # Arguments
/// * `a_g1` - Proof point A (G1, 64 bytes)
/// * `b_g2` - Proof point B (G2, 128 bytes)
/// * `alpha_g1_neg` - Negated alpha from VK (G1, 64 bytes)
/// * `beta_g2` - Beta from VK (G2, 128 bytes)
/// * `vk_x_neg` - Negated public input LC (G1, 64 bytes)
/// * `gamma_g2` - Gamma from VK (G2, 128 bytes)
/// * `c_g1_neg` - Negated proof point C (G1, 64 bytes)
/// * `delta_g2` - Delta from VK (G2, 128 bytes)
///
/// # Returns
/// * `Ok(true)` if the pairing check passes (proof valid)
/// * `Ok(false)` if the pairing check fails (proof invalid)
/// * `Err(...)` if the syscall fails
fn pairing_check(
    a_g1: &[u8; 64],
    b_g2: &[u8; 128],
    alpha_g1_neg: &[u8; 64],
    beta_g2: &[u8; 128],
    vk_x_neg: &[u8; 64],
    gamma_g2: &[u8; 128],
    c_g1_neg: &[u8; 64],
    delta_g2: &[u8; 128],
) -> Result<bool> {
    // Build pairing input: 4 pairs of (G1, G2), each pair is 192 bytes
    // Total: 768 bytes
    let mut pairing_input = [0u8; 768];

    // Pair 1: (A, B) - the proof
    pairing_input[0..64].copy_from_slice(a_g1);
    pairing_input[64..192].copy_from_slice(b_g2);

    // Pair 2: (-alpha, beta) - from verification key
    pairing_input[192..256].copy_from_slice(alpha_g1_neg);
    pairing_input[256..384].copy_from_slice(beta_g2);

    // Pair 3: (-vk_x, gamma) - public input contribution
    pairing_input[384..448].copy_from_slice(vk_x_neg);
    pairing_input[448..576].copy_from_slice(gamma_g2);

    // Pair 4: (-C, delta) - proof element
    pairing_input[576..640].copy_from_slice(c_g1_neg);
    pairing_input[640..768].copy_from_slice(delta_g2);

    // Call alt_bn128_pairing syscall
    let pairing_result = alt_bn128_pairing(&pairing_input)
        .map_err(|_| crate::errors::ShadowVestError::Bn128PairingFailed)?;

    // Result is 32 bytes: value of 1 (big-endian) means pairing product == identity
    // Check if result == 1 (last byte is 1, all others are 0)
    let mut is_valid = pairing_result[31] == 1;
    for i in 0..31 {
        if pairing_result[i] != 0 {
            is_valid = false;
            break;
        }
    }

    Ok(is_valid)
}

// ============================================================
// Wrapper functions for Solana alt_bn128 syscalls
//
// These call solana_bn254 operations which invoke the native
// sol_alt_bn128_group_op syscalls on-chain (target_os = "solana").
// Off-chain (tests), they use arkworks for computation.
// ============================================================

/// G1 point addition on alt_bn128.
/// Input: 128 bytes (two 64-byte G1 points concatenated)
/// Output: 64-byte G1 point (the sum)
fn alt_bn128_addition(input: &[u8; 128]) -> std::result::Result<[u8; 64], ()> {
    let result = solana_bn254::prelude::alt_bn128_addition(input)
        .map_err(|_| ())?;
    let mut output = [0u8; 64];
    if result.len() >= 64 {
        output.copy_from_slice(&result[..64]);
    }
    Ok(output)
}

/// G1 scalar multiplication on alt_bn128.
/// Input: 96 bytes (64-byte G1 point || 32-byte scalar, big-endian)
/// Output: 64-byte G1 point (the product)
fn alt_bn128_multiplication(input: &[u8; 96]) -> std::result::Result<[u8; 64], ()> {
    let result = solana_bn254::prelude::alt_bn128_multiplication(input)
        .map_err(|_| ())?;
    let mut output = [0u8; 64];
    if result.len() >= 64 {
        output.copy_from_slice(&result[..64]);
    }
    Ok(output)
}

/// Pairing check on alt_bn128.
/// Input: N * 192 bytes (N pairs of 64-byte G1 || 128-byte G2)
/// Output: 32-byte boolean (1 if pairing product == identity, 0 otherwise)
fn alt_bn128_pairing(input: &[u8]) -> std::result::Result<[u8; 32], ()> {
    let result = solana_bn254::prelude::alt_bn128_pairing(input)
        .map_err(|_| ())?;
    let mut output = [0u8; 32];
    if result.len() >= 32 {
        output.copy_from_slice(&result[..32]);
    }
    Ok(output)
}

// ============================================================
// Helper functions for converting public inputs to scalars
// ============================================================

impl WithdrawalPublicInputs {
    /// Convert withdrawal public inputs to an array of 32-byte scalars for Groth16 verification.
    /// Order must match the circuit's public input ordering.
    pub fn to_scalars(&self) -> Vec<[u8; 32]> {
        let mut epoch_scalar = [0u8; 32];
        // epoch_id as big-endian 32-byte scalar
        epoch_scalar[24..32].copy_from_slice(&self.epoch_id.to_be_bytes());

        vec![
            self.state_root,
            epoch_scalar,
            self.nullifier,
            self.withdrawal_commitment,
        ]
    }

    /// Number of public inputs for this circuit
    pub const NUM_PUBLIC_INPUTS: usize = 4;
}

impl IdentityPublicInputs {
    /// Convert identity public inputs to an array of 32-byte scalars.
    pub fn to_scalars(&self) -> Vec<[u8; 32]> {
        vec![self.position_commitment]
    }

    /// Number of public inputs for this circuit
    pub const NUM_PUBLIC_INPUTS: usize = 1;
}

impl EligibilityPublicInputs {
    /// Convert eligibility public inputs to an array of 32-byte scalars.
    pub fn to_scalars(&self) -> Vec<[u8; 32]> {
        vec![
            self.beneficiary_commitment,
            self.nullifier,
            self.position_id,
            self.position_commitment,
        ]
    }

    /// Number of public inputs for this circuit
    pub const NUM_PUBLIC_INPUTS: usize = 4;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_negate_g1_zero_point() {
        // Point at infinity (all zeros)
        let zero_point = [0u8; 64];
        let negated = negate_g1(&zero_point);
        assert_eq!(negated, zero_point);
    }

    #[test]
    fn test_negate_g1_known_point() {
        // Generator point G1 on alt_bn128:
        // x = 1, y = 2
        let mut point = [0u8; 64];
        point[31] = 1; // x = 1 (big-endian)
        point[63] = 2; // y = 2 (big-endian)

        let negated = negate_g1(&point);

        // x should be unchanged
        assert_eq!(&negated[..32], &point[..32]);

        // y should be p - 2
        // p = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD47
        // p - 2 = 0x30644E72E131A029B85045B68181585D97816A916871CA8D3C208C16D87CFD45
        assert_eq!(negated[63], 0x45); // Last byte of p-2
    }

    #[test]
    fn test_negate_g1_double_negation() {
        // Double negation should return the original point
        let mut point = [0u8; 64];
        point[31] = 1;
        point[63] = 2;

        let negated = negate_g1(&point);
        let double_negated = negate_g1(&negated);

        assert_eq!(double_negated, point);
    }

    #[test]
    fn test_withdrawal_public_inputs_to_scalars() {
        let inputs = WithdrawalPublicInputs {
            state_root: [1u8; 32],
            epoch_id: 42,
            nullifier: [2u8; 32],
            withdrawal_commitment: [3u8; 32],
        };

        let scalars = inputs.to_scalars();
        assert_eq!(scalars.len(), 4);
        assert_eq!(scalars[0], [1u8; 32]);
        // epoch_id = 42 as big-endian in last 8 bytes
        assert_eq!(scalars[1][24..32], 42u64.to_be_bytes());
        assert_eq!(scalars[2], [2u8; 32]);
        assert_eq!(scalars[3], [3u8; 32]);
    }

    #[test]
    fn test_identity_public_inputs_to_scalars() {
        let inputs = IdentityPublicInputs {
            position_commitment: [5u8; 32],
        };

        let scalars = inputs.to_scalars();
        assert_eq!(scalars.len(), 1);
        assert_eq!(scalars[0], [5u8; 32]);
    }

    #[test]
    fn test_eligibility_public_inputs_to_scalars() {
        let inputs = EligibilityPublicInputs {
            beneficiary_commitment: [10u8; 32],
            nullifier: [11u8; 32],
            position_id: [12u8; 32],
            position_commitment: [13u8; 32],
        };

        let scalars = inputs.to_scalars();
        assert_eq!(scalars.len(), 4);
        assert_eq!(scalars[0], [10u8; 32]);
        assert_eq!(scalars[1], [11u8; 32]);
        assert_eq!(scalars[2], [12u8; 32]);
        assert_eq!(scalars[3], [13u8; 32]);
    }
}
